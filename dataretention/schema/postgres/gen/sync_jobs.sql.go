// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sync_jobs.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelSyncJob = `-- name: CancelSyncJob :exec
UPDATE sync_jobs
SET status = $1,
    completed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type CancelSyncJobParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) CancelSyncJob(ctx context.Context, db DBTX, arg CancelSyncJobParams) error {
	_, err := db.Exec(ctx, cancelSyncJob, arg.Status, arg.ID)
	return err
}

const completeSyncJob = `-- name: CompleteSyncJob :exec
UPDATE sync_jobs
SET status = $1,
    completed_at = CURRENT_TIMESTAMP,
    duration_ms = $2,
    avg_processing_time_ms = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
`

type CompleteSyncJobParams struct {
	Status              string      `json:"status"`
	DurationMs          pgtype.Int4 `json:"duration_ms"`
	AvgProcessingTimeMs pgtype.Int4 `json:"avg_processing_time_ms"`
	ID                  uuid.UUID   `json:"id"`
}

func (q *Queries) CompleteSyncJob(ctx context.Context, db DBTX, arg CompleteSyncJobParams) error {
	_, err := db.Exec(ctx, completeSyncJob,
		arg.Status,
		arg.DurationMs,
		arg.AvgProcessingTimeMs,
		arg.ID,
	)
	return err
}

const createSyncJob = `-- name: CreateSyncJob :one
INSERT INTO sync_jobs (job_type, status, total_items, metadata)
VALUES ($1, $2, $3, $4)
RETURNING id, job_type, status, started_at, completed_at, total_items, processed_items, succeeded_items, failed_items, error_rate, success_rate, duration_ms, avg_processing_time_ms, metadata, error_message, created_at, updated_at
`

type CreateSyncJobParams struct {
	JobType    string `json:"job_type"`
	Status     string `json:"status"`
	TotalItems int32  `json:"total_items"`
	Metadata   []byte `json:"metadata"`
}

func (q *Queries) CreateSyncJob(ctx context.Context, db DBTX, arg CreateSyncJobParams) (*SyncJobs, error) {
	row := db.QueryRow(ctx, createSyncJob,
		arg.JobType,
		arg.Status,
		arg.TotalItems,
		arg.Metadata,
	)
	var i SyncJobs
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.TotalItems,
		&i.ProcessedItems,
		&i.SucceededItems,
		&i.FailedItems,
		&i.ErrorRate,
		&i.SuccessRate,
		&i.DurationMs,
		&i.AvgProcessingTimeMs,
		&i.Metadata,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const failSyncJob = `-- name: FailSyncJob :exec
UPDATE sync_jobs
SET status = $1,
    completed_at = CURRENT_TIMESTAMP,
    error_message = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3
`

type FailSyncJobParams struct {
	Status       string      `json:"status"`
	ErrorMessage pgtype.Text `json:"error_message"`
	ID           uuid.UUID   `json:"id"`
}

func (q *Queries) FailSyncJob(ctx context.Context, db DBTX, arg FailSyncJobParams) error {
	_, err := db.Exec(ctx, failSyncJob, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}

const getRecentSyncJobs = `-- name: GetRecentSyncJobs :many
SELECT id, job_type, status, started_at, completed_at, total_items, processed_items, succeeded_items, failed_items, error_rate, success_rate, duration_ms, avg_processing_time_ms, metadata, error_message, created_at, updated_at FROM sync_jobs
WHERE created_at >= $1
ORDER BY created_at DESC
`

func (q *Queries) GetRecentSyncJobs(ctx context.Context, db DBTX, createdAt pgtype.Timestamptz) ([]*SyncJobs, error) {
	rows, err := db.Query(ctx, getRecentSyncJobs, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SyncJobs
	for rows.Next() {
		var i SyncJobs
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.TotalItems,
			&i.ProcessedItems,
			&i.SucceededItems,
			&i.FailedItems,
			&i.ErrorRate,
			&i.SuccessRate,
			&i.DurationMs,
			&i.AvgProcessingTimeMs,
			&i.Metadata,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncJobByID = `-- name: GetSyncJobByID :one
SELECT id, job_type, status, started_at, completed_at, total_items, processed_items, succeeded_items, failed_items, error_rate, success_rate, duration_ms, avg_processing_time_ms, metadata, error_message, created_at, updated_at FROM sync_jobs
WHERE id = $1
`

func (q *Queries) GetSyncJobByID(ctx context.Context, db DBTX, id uuid.UUID) (*SyncJobs, error) {
	row := db.QueryRow(ctx, getSyncJobByID, id)
	var i SyncJobs
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.TotalItems,
		&i.ProcessedItems,
		&i.SucceededItems,
		&i.FailedItems,
		&i.ErrorRate,
		&i.SuccessRate,
		&i.DurationMs,
		&i.AvgProcessingTimeMs,
		&i.Metadata,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSyncJobMetrics = `-- name: GetSyncJobMetrics :one
SELECT 
    COUNT(*) as total_jobs,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_jobs,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_jobs,
    COUNT(*) FILTER (WHERE status = 'running') as running_jobs,
    SUM(total_items) as total_items_processed,
    SUM(succeeded_items) as total_succeeded,
    SUM(failed_items) as total_failed,
    AVG(success_rate) as avg_success_rate,
    AVG(error_rate) as avg_error_rate,
    AVG(duration_ms) as avg_duration_ms
FROM sync_jobs
WHERE created_at >= $1
`

type GetSyncJobMetricsRow struct {
	TotalJobs           int64   `json:"total_jobs"`
	CompletedJobs       int64   `json:"completed_jobs"`
	FailedJobs          int64   `json:"failed_jobs"`
	RunningJobs         int64   `json:"running_jobs"`
	TotalItemsProcessed int64   `json:"total_items_processed"`
	TotalSucceeded      int64   `json:"total_succeeded"`
	TotalFailed         int64   `json:"total_failed"`
	AvgSuccessRate      float64 `json:"avg_success_rate"`
	AvgErrorRate        float64 `json:"avg_error_rate"`
	AvgDurationMs       float64 `json:"avg_duration_ms"`
}

func (q *Queries) GetSyncJobMetrics(ctx context.Context, db DBTX, createdAt pgtype.Timestamptz) (*GetSyncJobMetricsRow, error) {
	row := db.QueryRow(ctx, getSyncJobMetrics, createdAt)
	var i GetSyncJobMetricsRow
	err := row.Scan(
		&i.TotalJobs,
		&i.CompletedJobs,
		&i.FailedJobs,
		&i.RunningJobs,
		&i.TotalItemsProcessed,
		&i.TotalSucceeded,
		&i.TotalFailed,
		&i.AvgSuccessRate,
		&i.AvgErrorRate,
		&i.AvgDurationMs,
	)
	return &i, err
}

const getSyncJobsByStatus = `-- name: GetSyncJobsByStatus :many
SELECT id, job_type, status, started_at, completed_at, total_items, processed_items, succeeded_items, failed_items, error_rate, success_rate, duration_ms, avg_processing_time_ms, metadata, error_message, created_at, updated_at FROM sync_jobs
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetSyncJobsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetSyncJobsByStatus(ctx context.Context, db DBTX, arg GetSyncJobsByStatusParams) ([]*SyncJobs, error) {
	rows, err := db.Query(ctx, getSyncJobsByStatus, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SyncJobs
	for rows.Next() {
		var i SyncJobs
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.TotalItems,
			&i.ProcessedItems,
			&i.SucceededItems,
			&i.FailedItems,
			&i.ErrorRate,
			&i.SuccessRate,
			&i.DurationMs,
			&i.AvgProcessingTimeMs,
			&i.Metadata,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncJobsByType = `-- name: GetSyncJobsByType :many
SELECT id, job_type, status, started_at, completed_at, total_items, processed_items, succeeded_items, failed_items, error_rate, success_rate, duration_ms, avg_processing_time_ms, metadata, error_message, created_at, updated_at FROM sync_jobs
WHERE job_type = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetSyncJobsByTypeParams struct {
	JobType string `json:"job_type"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) GetSyncJobsByType(ctx context.Context, db DBTX, arg GetSyncJobsByTypeParams) ([]*SyncJobs, error) {
	rows, err := db.Query(ctx, getSyncJobsByType, arg.JobType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SyncJobs
	for rows.Next() {
		var i SyncJobs
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.TotalItems,
			&i.ProcessedItems,
			&i.SucceededItems,
			&i.FailedItems,
			&i.ErrorRate,
			&i.SuccessRate,
			&i.DurationMs,
			&i.AvgProcessingTimeMs,
			&i.Metadata,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllSyncJobs = `-- name: ListAllSyncJobs :many
SELECT id, job_type, status, started_at, completed_at, total_items, processed_items, succeeded_items, failed_items, error_rate, success_rate, duration_ms, avg_processing_time_ms, metadata, error_message, created_at, updated_at FROM sync_jobs
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListAllSyncJobs(ctx context.Context, db DBTX, limit int32) ([]*SyncJobs, error) {
	rows, err := db.Query(ctx, listAllSyncJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SyncJobs
	for rows.Next() {
		var i SyncJobs
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.TotalItems,
			&i.ProcessedItems,
			&i.SucceededItems,
			&i.FailedItems,
			&i.ErrorRate,
			&i.SuccessRate,
			&i.DurationMs,
			&i.AvgProcessingTimeMs,
			&i.Metadata,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSyncJobProgress = `-- name: UpdateSyncJobProgress :exec
UPDATE sync_jobs
SET processed_items = processed_items + $1,
    succeeded_items = succeeded_items + $2,
    failed_items = failed_items + $3,
    error_rate = CASE 
        WHEN (processed_items + $1) > 0 THEN ROUND(((failed_items + $3)::DECIMAL / (processed_items + $1)::DECIMAL) * 100, 2)
        ELSE 0.00
    END,
    success_rate = CASE
        WHEN (processed_items + $1) > 0 THEN ROUND(((succeeded_items + $2)::DECIMAL / (processed_items + $1)::DECIMAL) * 100, 2)
        ELSE 0.00
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
`

type UpdateSyncJobProgressParams struct {
	ProcessedItems int32     `json:"processed_items"`
	SucceededItems int32     `json:"succeeded_items"`
	FailedItems    int32     `json:"failed_items"`
	ID             uuid.UUID `json:"id"`
}

func (q *Queries) UpdateSyncJobProgress(ctx context.Context, db DBTX, arg UpdateSyncJobProgressParams) error {
	_, err := db.Exec(ctx, updateSyncJobProgress,
		arg.ProcessedItems,
		arg.SucceededItems,
		arg.FailedItems,
		arg.ID,
	)
	return err
}

const updateSyncJobStatus = `-- name: UpdateSyncJobStatus :exec
UPDATE sync_jobs
SET status = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateSyncJobStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateSyncJobStatus(ctx context.Context, db DBTX, arg UpdateSyncJobStatusParams) error {
	_, err := db.Exec(ctx, updateSyncJobStatus, arg.Status, arg.ID)
	return err
}
