// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: message_queue.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const dequeueMessages = `-- name: DequeueMessages :many
UPDATE message_queue
SET status = $1, processed_at = $2
WHERE id IN (
    SELECT id FROM message_queue mq
    WHERE mq.status = $3
        AND (mq.next_retry_at IS NULL OR mq.next_retry_at <= $2)
    ORDER BY mq.priority ASC, mq.created_at ASC
    LIMIT $4
    FOR UPDATE SKIP LOCKED
)
RETURNING id, message_type, payload, status, priority, retry_count, max_retries, error_message, created_at, processed_at, next_retry_at
`

type DequeueMessagesParams struct {
	Status      string             `json:"status"`
	ProcessedAt pgtype.Timestamptz `json:"processed_at"`
	Status_2    string             `json:"status_2"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) DequeueMessages(ctx context.Context, db DBTX, arg DequeueMessagesParams) ([]*MessageQueue, error) {
	rows, err := db.Query(ctx, dequeueMessages,
		arg.Status,
		arg.ProcessedAt,
		arg.Status_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MessageQueue
	for rows.Next() {
		var i MessageQueue
		if err := rows.Scan(
			&i.ID,
			&i.MessageType,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.NextRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const enqueueMessage = `-- name: EnqueueMessage :one
INSERT INTO message_queue (message_type, payload, priority, status, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, message_type, payload, status, priority, retry_count, max_retries, error_message, created_at, processed_at, next_retry_at
`

type EnqueueMessageParams struct {
	MessageType string             `json:"message_type"`
	Payload     []byte             `json:"payload"`
	Priority    int32              `json:"priority"`
	Status      string             `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) EnqueueMessage(ctx context.Context, db DBTX, arg EnqueueMessageParams) (*MessageQueue, error) {
	row := db.QueryRow(ctx, enqueueMessage,
		arg.MessageType,
		arg.Payload,
		arg.Priority,
		arg.Status,
		arg.CreatedAt,
	)
	var i MessageQueue
	err := row.Scan(
		&i.ID,
		&i.MessageType,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.NextRetryAt,
	)
	return &i, err
}

const failMessageWithRetry = `-- name: FailMessageWithRetry :exec
UPDATE message_queue
SET status = $1, retry_count = $2, error_message = $3, next_retry_at = $4
WHERE id = $5
`

type FailMessageWithRetryParams struct {
	Status       string             `json:"status"`
	RetryCount   int32              `json:"retry_count"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	NextRetryAt  pgtype.Timestamptz `json:"next_retry_at"`
	ID           uuid.UUID          `json:"id"`
}

func (q *Queries) FailMessageWithRetry(ctx context.Context, db DBTX, arg FailMessageWithRetryParams) error {
	_, err := db.Exec(ctx, failMessageWithRetry,
		arg.Status,
		arg.RetryCount,
		arg.ErrorMessage,
		arg.NextRetryAt,
		arg.ID,
	)
	return err
}

const getDeadLetterMessages = `-- name: GetDeadLetterMessages :many
SELECT id, message_type, payload, status, priority, retry_count, max_retries, error_message, created_at, processed_at, next_retry_at FROM message_queue
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetDeadLetterMessagesParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetDeadLetterMessages(ctx context.Context, db DBTX, arg GetDeadLetterMessagesParams) ([]*MessageQueue, error) {
	rows, err := db.Query(ctx, getDeadLetterMessages, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MessageQueue
	for rows.Next() {
		var i MessageQueue
		if err := rows.Scan(
			&i.ID,
			&i.MessageType,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.NextRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, message_type, payload, status, priority, retry_count, max_retries, error_message, created_at, processed_at, next_retry_at FROM message_queue
WHERE id = $1
`

func (q *Queries) GetMessageByID(ctx context.Context, db DBTX, id uuid.UUID) (*MessageQueue, error) {
	row := db.QueryRow(ctx, getMessageByID, id)
	var i MessageQueue
	err := row.Scan(
		&i.ID,
		&i.MessageType,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.NextRetryAt,
	)
	return &i, err
}

const getMessageState = `-- name: GetMessageState :one
SELECT retry_count, max_retries FROM message_queue
WHERE id = $1
`

type GetMessageStateRow struct {
	RetryCount int32 `json:"retry_count"`
	MaxRetries int32 `json:"max_retries"`
}

func (q *Queries) GetMessageState(ctx context.Context, db DBTX, id uuid.UUID) (*GetMessageStateRow, error) {
	row := db.QueryRow(ctx, getMessageState, id)
	var i GetMessageStateRow
	err := row.Scan(&i.RetryCount, &i.MaxRetries)
	return &i, err
}

const getPendingMessagesForRetry = `-- name: GetPendingMessagesForRetry :many
SELECT id, message_type, payload, status, priority, retry_count, max_retries, error_message, created_at, processed_at, next_retry_at FROM message_queue
WHERE status = $1
    AND next_retry_at IS NOT NULL
    AND next_retry_at <= $2
ORDER BY priority ASC, created_at ASC
LIMIT $3
`

type GetPendingMessagesForRetryParams struct {
	Status      string             `json:"status"`
	NextRetryAt pgtype.Timestamptz `json:"next_retry_at"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) GetPendingMessagesForRetry(ctx context.Context, db DBTX, arg GetPendingMessagesForRetryParams) ([]*MessageQueue, error) {
	rows, err := db.Query(ctx, getPendingMessagesForRetry, arg.Status, arg.NextRetryAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MessageQueue
	for rows.Next() {
		var i MessageQueue
		if err := rows.Scan(
			&i.ID,
			&i.MessageType,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.RetryCount,
			&i.MaxRetries,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.NextRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageStatus = `-- name: UpdateMessageStatus :exec
UPDATE message_queue
SET status = $1, processed_at = $2
WHERE id = $3
`

type UpdateMessageStatusParams struct {
	Status      string             `json:"status"`
	ProcessedAt pgtype.Timestamptz `json:"processed_at"`
	ID          uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateMessageStatus(ctx context.Context, db DBTX, arg UpdateMessageStatusParams) error {
	_, err := db.Exec(ctx, updateMessageStatus, arg.Status, arg.ProcessedAt, arg.ID)
	return err
}

const updateMessageStatusWithError = `-- name: UpdateMessageStatusWithError :exec
UPDATE message_queue
SET status = $1, processed_at = $2, error_message = $4
WHERE id = $3
`

type UpdateMessageStatusWithErrorParams struct {
	Status       string             `json:"status"`
	ProcessedAt  pgtype.Timestamptz `json:"processed_at"`
	ID           uuid.UUID          `json:"id"`
	ErrorMessage pgtype.Text        `json:"error_message"`
}

func (q *Queries) UpdateMessageStatusWithError(ctx context.Context, db DBTX, arg UpdateMessageStatusWithErrorParams) error {
	_, err := db.Exec(ctx, updateMessageStatusWithError,
		arg.Status,
		arg.ProcessedAt,
		arg.ID,
		arg.ErrorMessage,
	)
	return err
}
